C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:50:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TRAFFIC_LIGHT
OBJECT MODULE PLACED IN .\Objects\traffic_light.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE traffic_light.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\traffic_light.lst) TABS(2) OBJECT(.\Objects\traffic_light.obj)

line level    source

   1          #include "headfile.h"
   2          
   3          #define DONT_DISPLAY 255 // DisplayDigit函数的val为该值时，两位均不显示
   4          #define SEG_OFF 15       // Write7219向某位数码管写入该值时，该位数码管不显示
   5          
   6          typedef enum digs_addr
   7          {
   8              EAST_TENS = 1,
   9              EAST_ONES,
  10              SOUTH_TENS,
  11              SOUTH_ONES,
  12              WEST_TENS,
  13              WEST_ONES,
  14              NORTH_TENS,
  15              NORTH_ONES,
  16          } digs_addr;
  17          
  18          // static uchar last_east, last_south, last_west, last_north;
  19          static uchar last_display_val[4];
  20          digs_addr code ONES_BIT[] = {EAST_ONES, SOUTH_ONES, WEST_ONES, NORTH_ONES};
  21          digs_addr code TENS_BIT[] = {EAST_TENS, SOUTH_TENS, WEST_TENS, NORTH_TENS};
  22          uchar remain_time[4];
  23          uchar red_time[4];
  24          uchar yellow_time[4];
  25          uchar green_time[4];
  26          
  27          void TrafficLightInit()
  28          {
  29   1          red_time[EAST] = 60, yellow_time[EAST] = 10, green_time[EAST] = 20;
  30   1          red_time[SOUTH] = 60, yellow_time[SOUTH] = 10, green_time[SOUTH] = 20;
  31   1          red_time[WEST] = 60, yellow_time[WEST] = 10, green_time[WEST] = 20;
  32   1          red_time[NORTH] = 60, yellow_time[NORTH] = 10, green_time[NORTH] = 20;
  33   1      
  34   1          remain_time[EAST] = green_time[EAST];
  35   1          remain_time[SOUTH] = red_time[SOUTH];
  36   1          remain_time[NORTH] = red_time[NORTH];
  37   1          remain_time[WEST] = red_time[WEST];
  38   1      }
  39          
  40          void Write7219(unsigned char address, unsigned char dat)
  41          {
  42   1          unsigned char i;
  43   1          LOAD_7219 = 0; // 拉低片选线，选中器件
  44   1          // 发送地址
  45   1          for (i = 0; i < 8; i++) // 移位循环8次
  46   1          {
  47   2              CLK_7219 = 0;                     // 清零时钟总线
  48   2              DIN_7219 = (bit)(address & 0x80); // 每次取高字节
  49   2              address <<= 1;                    // 左移一位
  50   2              CLK_7219 = 1;                     // 时钟上升沿，发送地址
  51   2          }
  52   1          // 发送数据
  53   1          for (i = 0; i < 8; i++)
  54   1          {
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:50:24 PAGE 2   

  55   2              CLK_7219 = 0;
  56   2              DIN_7219 = (bit)(dat & 0x80);
  57   2              dat <<= 1;
  58   2              CLK_7219 = 1; // 时钟上升沿，发送数据
  59   2          }
  60   1          LOAD_7219 = 1; // 发送结束，上升沿锁存数据
  61   1      }
  62          
  63          // MAX7219初始化，设置MAX7219内部的控制寄存器
  64          void Init7219(void)
  65          {
  66   1          Write7219(SHUT_DOWN, 0x01);    // 开启正常工作模式（0xX1）
  67   1          Write7219(DISPLAY_TEST, 0x00); // 选择工作模式（0xX0）
  68   1          Write7219(DECODE_MODE, 0xff);  // 选用全译码模式
  69   1          Write7219(SCAN_LIMIT, 0x07);   // 8只LED全用
  70   1          Write7219(INTENSITY, 0x04);    // 设置初始亮度
  71   1      }
  72          
  73          void DisplayDigit(uchar val, direction dir)
  74          {
  75   1          // @brief 在dir方向展示val,并将本次显示的值保存在last_变量中
  76   1          // @note  这是唯一允许调用数码管显示的方式
  77   1          static uchar ones, tens;
  78   1      
  79   1          if (val == DONT_DISPLAY)
  80   1          {
  81   2              // 两位均不显示
  82   2              ones = SEG_OFF;
  83   2              tens = SEG_OFF;
  84   2          }
  85   1          else
  86   1          {
  87   2              ones = val % 10;
  88   2              tens = (val / 10 % 10) == 0 ? SEG_OFF : (val / 10 % 10); // 如果十位为0，则不显示
  89   2          }
  90   1      
  91   1          Write7219(ONES_BIT[dir], ones);
  92   1          Write7219(TENS_BIT[dir], tens);
  93   1      
  94   1          if (val == DONT_DISPLAY)
  95   1              last_display_val[dir] = last_display_val[dir];
  96   1          else
  97   1              last_display_val[dir] = val;
  98   1      }
  99          
 100          void DisplayDigitDemo()
 101          {
 102   1          Write7219(1, 1); // 15为全灭
 103   1          Write7219(2, 2);
 104   1          Write7219(3, 3);
 105   1          Write7219(4, 4);
 106   1          Write7219(5, 5);
 107   1          Write7219(6, 6);
 108   1          Write7219(7, 7);
 109   1          Write7219(8, 8);
 110   1          // Write7219(1, 15); // 15为全灭
 111   1      }
 112          
 113          void TrafficLight()
 114          {
 115   1          DisplayDigit(remain_time[EAST], EAST);
 116   1          DisplayDigit(remain_time[SOUTH], SOUTH);
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:50:24 PAGE 3   

 117   1          DisplayDigit(remain_time[WEST], WEST);
 118   1          DisplayDigit(remain_time[NORTH], NORTH);
 119   1      }
 120          
 121          void Setting()
 122          {
 123   1          direction dir = NORTH;
 124   1          while (mode == SETTING)
 125   1          {
 126   2              ToggleSegs(dir);
 127   2              DelayMS(1000);
 128   2          }
 129   1          ClockReset();
 130   1      }
 131          
 132          void ClockReset()
 133          {
 134   1          // @brief 重置定时器0以及毫秒、秒计数器
 135   1          TR0 = 0;    // 定时器0开始计时
 136   1          ET0 = 0;    // 关闭定时器0中断
 137   1          TL0 = 0x20; // 设置定时初始值
 138   1          TH0 = 0xD1; // 设置定时初始值
 139   1          milliseconds = 0;
 140   1          seconds = 0;
 141   1          ET0 = 1;
 142   1          TR0 = 1; // 定时器0开始计时
 143   1      }
 144          
 145          void ToggleSegs(direction dir)
 146          {
 147   1          // @note: 向方向写入DONT_DISPLAY可以使数码管熄灭
 148   1          static uchar ON[4] = {1, 1, 1, 1}; // 4个方向的开关状态
 149   1          if (ON[dir] == 1)
 150   1          {
 151   2              DisplayDigit(DONT_DISPLAY, dir);
 152   2              ON[dir] = 0;
 153   2          }
 154   1          else
 155   1          {
 156   2              DisplayDigit(last_display_val[dir], dir);
 157   2              ON[dir] = 1;
 158   2          }
 159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    406    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
