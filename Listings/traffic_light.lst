<<<<<<< HEAD
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 22:24:31 PAGE 1   
=======
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:20:18 PAGE 1   
>>>>>>> 3f15c7988e679a888b842c010a439492e67b8d3b


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TRAFFIC_LIGHT
OBJECT MODULE PLACED IN .\Objects\traffic_light.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE traffic_light.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\traffic_light.lst) TABS(2) OBJECT(.\Objects\traffic_light.obj)

line level    source

   1          #include "headfile.h"
   2          
   3          #define DONT_DISPLAY 255 // DisplayDigit函数的val为该值时，两位均不显示
   4          #define SEG_OFF 15       // Write7219向某位数码管写入该值时，该位数码管不显示
   5          
<<<<<<< HEAD
   6          static uchar last_display_val[4];
   7          digs_addr code ONES_BIT[] = {EAST_ONES, SOUTH_ONES, WEST_ONES, NORTH_ONES};
   8          digs_addr code TENS_BIT[] = {EAST_TENS, SOUTH_TENS, WEST_TENS, NORTH_TENS};
   9          uchar remain_time[4];
  10          uchar red_time[4];
  11          uchar yellow_time[4];
  12          uchar green_time[4];
  13          uchar current_color[4];
  14          
  15          void TrafficLightInit()
  16          {
  17   1          uchar i;
  18   1          for (i = 0; i < TRAFFIC_LIGHT_MAX; i++)
  19   1          {
  20   2              SetLedBit(i, LED_OFF);
  21   2          }
  22   1          // 初始状态
  23   1          red_time[EAST] = 60, yellow_time[EAST] = 10, green_time[EAST] = 20;
  24   1          red_time[SOUTH] = 60, yellow_time[SOUTH] = 10, green_time[SOUTH] = 20;
  25   1          red_time[WEST] = 60, yellow_time[WEST] = 10, green_time[WEST] = 20;
  26   1          red_time[NORTH] = 60, yellow_time[NORTH] = 10, green_time[NORTH] = 20;
  27   1      
  28   1          remain_time[EAST] = green_time[EAST];
  29   1          remain_time[SOUTH] = red_time[SOUTH];
  30   1          remain_time[NORTH] = red_time[NORTH];
  31   1          remain_time[WEST] = red_time[WEST];
  32   1      
  33   1          current_color[EAST] = GREEN;
  34   1          current_color[SOUTH] = RED;
  35   1          current_color[WEST] = RED;
  36   1          current_color[NORTH] = RED;
  37   1      }
  38          
  39          void Write7219(unsigned char address, unsigned char dat)
  40          {
  41   1          unsigned char i;
  42   1          LOAD_7219 = 0; // 拉低片选线，选中器件
  43   1          // 发送地址
  44   1          for (i = 0; i < 8; i++) // 移位循环8次
  45   1          {
  46   2              CLK_7219 = 0;                     // 清零时钟总线
  47   2              DIN_7219 = (bit)(address & 0x80); // 每次取高字节
  48   2              address <<= 1;                    // 左移一位
  49   2              CLK_7219 = 1;                     // 时钟上升沿，发送地址
  50   2          }
  51   1          // 发送数据
  52   1          for (i = 0; i < 8; i++)
  53   1          {
  54   2              CLK_7219 = 0;
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 22:24:31 PAGE 2   

  55   2              DIN_7219 = (bit)(dat & 0x80);
  56   2              dat <<= 1;
  57   2              CLK_7219 = 1; // 时钟上升沿，发送数据
  58   2          }
  59   1          LOAD_7219 = 1; // 发送结束，上升沿锁存数据
  60   1      }
  61          
  62          // MAX7219初始化，设置MAX7219内部的控制寄存器
  63          void Init7219(void)
  64          {
  65   1          Write7219(SHUT_DOWN, 0x01);    // 开启正常工作模式（0xX1）
  66   1          Write7219(DISPLAY_TEST, 0x00); // 选择工作模式（0xX0）
  67   1          Write7219(DECODE_MODE, 0xff);  // 选用全译码模式
  68   1          Write7219(SCAN_LIMIT, 0x07);   // 8只LED全用
  69   1          Write7219(INTENSITY, 0x04);    // 设置初始亮度
  70   1      }
  71          
  72          void DisplayDigit(uchar val, direction dir)
  73          {
  74   1          // @brief 在dir方向展示val,并将本次显示的值保存在last_变量中
  75   1          // @note  这是唯一允许调用数码管显示的方式
  76   1          static uchar ones, tens;
  77   1      
  78   1          if (val == DONT_DISPLAY)
  79   1          {
  80   2              // 两位均不显示
  81   2              ones = SEG_OFF;
  82   2              tens = SEG_OFF;
  83   2          }
  84   1          else
  85   1          {
  86   2              ones = val % 10;
  87   2              tens = (val / 10 % 10) == 0 ? SEG_OFF : (val / 10 % 10); // 如果十位为0，则不显示
  88   2          }
  89   1      
  90   1          Write7219(ONES_BIT[dir], ones);
  91   1          Write7219(TENS_BIT[dir], tens);
  92   1      
  93   1          if (val == DONT_DISPLAY)
  94   1              last_display_val[dir] = last_display_val[dir];
  95   1          else
  96   1              last_display_val[dir] = val;
  97   1      }
  98          
  99          uchar GetReloadValue(TrafficLightColor next_status, direction dir)
 100          {
 101   1          switch (next_status)
 102   1          {
 103   2          case RED:
 104   2              return red_time[dir];
 105   2          case YELLOW:
 106   2              return yellow_time[dir];
 107   2          case GREEN:
 108   2              return green_time[dir];
 109   2          default:
 110   2              break;
 111   2          }
 112   1      }
 113          
 114          void DisplayDigitDemo()
 115          {
 116   1          Write7219(1, 1); // 15为全灭
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 22:24:31 PAGE 3   

 117   1          Write7219(2, 2);
 118   1          Write7219(3, 3);
 119   1          Write7219(4, 4);
 120   1          Write7219(5, 5);
 121   1          Write7219(6, 6);
 122   1          Write7219(7, 7);
 123   1          Write7219(8, 8);
 124   1          // Write7219(1, 15); // 15为全灭
 125   1      }
 126          
 127          void TrafficLight()
 128          {
 129   1          uchar dir;
 130   1          if (new_second_flag)
 131   1          {
 132   2              for (dir = 0; dir < DIRECTION_MAX; dir++)
 133   2              {
 134   3                  remain_time[dir]--;       // 各方向倒计时更新
 135   3                  if (remain_time[dir] < 5) // 判断是否需要闪烁
 136   3                  {
 137   4                      ToggleLedBit(dir);
 138   4                  }
 139   3                  if (remain_time[dir] < 0)
 140   3                  {
 141   4                      // 装载下一个状态
 142   4                      remain_time[dir] = GetReloadValue(dir, current_color[dir]);
 143   4                  }
 144   3      
 145   3                  // 显示结果
 146   3                  DisplayDigit(remain_time[dir], dir);
 147   3                  // SetLedColor(dir, );
 148   3              }
 149   2              new_second_flag = 0; // 清除标志位
 150   2          }
 151   1          else
 152   1              return;
 153   1      }
 154          
 155          void Setting()
 156          {
 157   1          direction dir = NORTH;
 158   1          while (mode == SETTING)
 159   1          {
 160   2              ToggleSegs(dir);
 161   2              DelayMS(1000);
 162   2          }
 163   1          ClockReset();
 164   1      }
 165          
 166          void ClockReset()
 167          {
 168   1          // @brief 重置定时器0以及毫秒、秒计数器
 169   1          TR0 = 0;    // 定时器0开始计时
 170   1          ET0 = 0;    // 关闭定时器0中断
 171   1          TL0 = 0x20; // 设置定时初始值
 172   1          TH0 = 0xD1; // 设置定时初始值
 173   1          milliseconds = 0;
 174   1          seconds = 0;
 175   1          ET0 = 1;
 176   1          TR0 = 1; // 定时器0开始计时
 177   1      }
 178          
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 22:24:31 PAGE 4   

 179          void ToggleSegs(direction dir)
 180          {
 181   1          // @note: 向方向写入DONT_DISPLAY可以使数码管熄灭
 182   1          static uchar ON[4] = {1, 1, 1, 1}; // 4个方向的开关状态
 183   1          if (ON[dir] == 1)
 184   1          {
 185   2              DisplayDigit(DONT_DISPLAY, dir);
 186   2              ON[dir] = 0;
 187   2          }
 188   1          else
 189   1          {
 190   2              DisplayDigit(last_display_val[dir], dir);
 191   2              ON[dir] = 1;
 192   2          }
 193   1      }
 194          
 195          void SetLedColor(direction dir, TrafficLightColor color)
 196          {
 197   1          /**
 198   1           * @brief 设置dir方向的灯色
 199   1           * @ref 参见TrafficLight枚举
 200   1           */
 201   1          SetLedBit(GetDstLed(dir, current_color[dir]), LED_OFF);
 202   1          SetLedBit(GetDstLed(dir, color), LED_ON);
 203   1          current_color[dir] = color;
 204   1      }
 205          
 206          uchar GetDstLed(direction dir, TrafficLightColor color)
 207          {
 208   1          /**
 209   1           * @brief 获取dir方向color颜色的LED对应的LEDs枚举变量
 210   1           */
 211   1          uchar dst_led = 0;
 212   1          switch (dir)
 213   1          {
 214   2          case NORTH:
 215   2              dst_led = 0;
 216   2              break;
 217   2          case WEST:
 218   2              dst_led = 3;
 219   2              break;
 220   2          case SOUTH:
 221   2              dst_led = 6;
 222   2              break;
 223   2          case EAST:
 224   2              dst_led = 9;
 225   2              break;
 226   2          default:
 227   2              break;
 228   2          }
 229   1          switch (color)
 230   1          {
 231   2          case GREEN:
 232   2              break;
 233   2          case YELLOW:
 234   2              dst_led += 1;
 235   2              break;
 236   2          case RED:
 237   2              dst_led += 2;
 238   2              break;
 239   2          default:
 240   2              break;
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 22:24:31 PAGE 5   

 241   2          }
 242   1          return dst_led;
 243   1      }
*** WARNING C291 IN LINE 112 OF traffic_light.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    607    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30       5
=======
   6          typedef enum digs
   7          {
   8              EAST_TENS = 1,
   9              EAST_ONES,
  10              SOUTH_TENS,
  11              SOUTH_ONES,
  12              WEST_TENS,
  13              WEST_ONES,
  14              NORTH_TENS,
  15              NORTH_ONES,
  16          } digs;
  17          
  18          // static uchar last_east, last_south, last_west, last_north;
  19          static uchar last_display_val[4];
  20          const uchar ONES_BIT[] = {EAST_ONES, SOUTH_ONES, WEST_ONES, NORTH_ONES};
  21          const uchar TENS_BIT[] = {EAST_TENS, SOUTH_TENS, WEST_TENS, NORTH_TENS};
  22          uchar remain_time[4];
  23          uchar red_time[4];
  24          uchar yellow_time[4];
  25          uchar green_time[4];
  26          
  27          void TrafficLightInit()
  28          {
  29   1          red_time[EAST] = 60, yellow_time[EAST] = 10, green_time[EAST] = 20;
  30   1          red_time[SOUTH] = 60, yellow_time[SOUTH] = 10, green_time[SOUTH] = 20;
  31   1          red_time[WEST] = 60, yellow_time[WEST] = 10, green_time[WEST] = 20;
  32   1          red_time[NORTH] = 60, yellow_time[NORTH] = 10, green_time[NORTH] = 20;
  33   1      
  34   1          remain_time[EAST] = green_time[EAST];
  35   1          remain_time[SOUTH] = red_time[SOUTH];
  36   1          remain_time[NORTH] = red_time[NORTH];
  37   1          remain_time[WEST] = red_time[WEST];
  38   1      }
  39          
  40          void Write7219(unsigned char address, unsigned char dat)
  41          {
  42   1          unsigned char i;
  43   1          LOAD_7219 = 0; // 拉低片选线，选中器件
  44   1          // 发送地址
  45   1          for (i = 0; i < 8; i++) // 移位循环8次
  46   1          {
  47   2              CLK_7219 = 0;                     // 清零时钟总线
  48   2              DIN_7219 = (bit)(address & 0x80); // 每次取高字节
  49   2              address <<= 1;                    // 左移一位
  50   2              CLK_7219 = 1;                     // 时钟上升沿，发送地址
  51   2          }
  52   1          // 发送数据
  53   1          for (i = 0; i < 8; i++)
  54   1          {
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:20:18 PAGE 2   

  55   2              CLK_7219 = 0;
  56   2              DIN_7219 = (bit)(dat & 0x80);
  57   2              dat <<= 1;
  58   2              CLK_7219 = 1; // 时钟上升沿，发送数据
  59   2          }
  60   1          LOAD_7219 = 1; // 发送结束，上升沿锁存数据
  61   1      }
  62          
  63          // MAX7219初始化，设置MAX7219内部的控制寄存器
  64          void Init7219(void)
  65          {
  66   1          Write7219(SHUT_DOWN, 0x01);    // 开启正常工作模式（0xX1）
  67   1          Write7219(DISPLAY_TEST, 0x00); // 选择工作模式（0xX0）
  68   1          Write7219(DECODE_MODE, 0xff);  // 选用全译码模式
  69   1          Write7219(SCAN_LIMIT, 0x07);   // 8只LED全用
  70   1          Write7219(INTENSITY, 0x04);    // 设置初始亮度
  71   1      }
  72          
  73          void DisplayDigit(uchar val, direction dir)
  74          {
  75   1          // @brief 在dir方向展示val,并将本次显示的值保存在last_变量中
  76   1          // @note  这是唯一允许调用数码管显示的方式
  77   1          static uchar ones, tens;
  78   1      
  79   1          if (val == DONT_DISPLAY)
  80   1          {
  81   2              // 两位均不显示
  82   2              ones = SEG_OFF;
  83   2              tens = SEG_OFF;
  84   2          }
  85   1          else
  86   1          {
  87   2              ones = val % 10;
  88   2              tens = (val / 10 % 10) == 0 ? SEG_OFF : (val / 10 % 10); // 如果十位为0，则不显示
  89   2          }
  90   1      
  91   1          Write7219(ONES_BIT[dir], ones);
  92   1          Write7219(TENS_BIT[dir], tens);
  93   1      
  94   1          if (val == DONT_DISPLAY)
  95   1              last_display_val[dir] = last_display_val[dir];
  96   1          else
  97   1              last_display_val[dir] = val;
  98   1      }
  99          
 100          void DisplayDigitDemo()
 101          {
 102   1          Write7219(1, 1); // 15为全灭
 103   1          Write7219(2, 2);
 104   1          Write7219(3, 3);
 105   1          Write7219(4, 4);
 106   1          Write7219(5, 5);
 107   1          Write7219(6, 6);
 108   1          Write7219(7, 7);
 109   1          Write7219(8, 8);
 110   1          // Write7219(1, 15); // 15为全灭
 111   1      }
 112          
 113          void TrafficLight()
 114          {
 115   1          DisplayDigit(remain_time[EAST], EAST);
 116   1          DisplayDigit(remain_time[SOUTH], SOUTH);
C51 COMPILER V9.60.0.0   TRAFFIC_LIGHT                                                     12/13/2022 09:20:18 PAGE 3   

 117   1          DisplayDigit(remain_time[WEST], WEST);
 118   1          DisplayDigit(remain_time[NORTH], NORTH);
 119   1      }
 120          
 121          void Setting()
 122          {
 123   1          direction dir = NORTH;
 124   1          while (mode == SETTING)
 125   1          {
 126   2              ToggleSegs(dir);
 127   2              DelayMS(1000);
 128   2          }
 129   1          ClockReset();
 130   1      }
 131          
 132          void ClockReset()
 133          {
 134   1          // @brief 重置定时器0以及毫秒、秒计数器
 135   1          TR0 = 0;    // 定时器0开始计时
 136   1          ET0 = 0;    // 关闭定时器0中断
 137   1          TL0 = 0x20; // 设置定时初始值
 138   1          TH0 = 0xD1; // 设置定时初始值
 139   1          milliseconds = 0;
 140   1          seconds = 0;
 141   1          ET0 = 1;
 142   1          TR0 = 1; // 定时器0开始计时
 143   1      }
 144          
 145          void ToggleSegs(direction dir)
 146          {
 147   1          // @note: 向方向写入DONT_DISPLAY可以使数码管熄灭
 148   1          static uchar ON[4] = {1, 1, 1, 1}; // 4个方向的开关状态
 149   1          if (ON[dir] == 1)
 150   1          {
 151   2              DisplayDigit(DONT_DISPLAY, dir);
 152   2              ON[dir] = 0;
 153   2          }
 154   1          else
 155   1          {
 156   2              DisplayDigit(last_display_val[dir], dir);
 157   2              ON[dir] = 1;
 158   2          }
 159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    406    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34       1
>>>>>>> 3f15c7988e679a888b842c010a439492e67b8d3b
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
